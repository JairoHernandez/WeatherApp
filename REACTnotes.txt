------Controlled Components and Binding Context------

The state should tell the input what its value should be.

EXAMPLE:
    <input onChange={event => this.setState({ term: event.target.value })} />

Whenever you are passing a callback like this 

    <input onChange={this.onInputChange} />

you need to bind the context like this

    constructor(props) {
        super(props);

        this.state = { term: ''};

        // Take existing fuction onInputChange and bind it to this.
        // where this inside bind is SearchBar
        this.onInputChange = this.onInputChange.bind(this); 
    }

Other wise you will get this error:  Uncaught TypeError: Cannot read property 'setState' of undefined
Another way is to pass in the arrow function into <input onChange={} /> but that looks ugly:
    
    onChange={event => this.onInputChange(event.target.value)} />

------Form Elements in React------

To prevent full page reload add an even handler to form element.

------Working wiht APIs------

website --> openweathermap.org/forecast5

API call:
api.openweathermap.org/data/2.5/forecast?q={city name},{country code}

------Introduction to MiddleWare------

Middleware sits in between returning an action and the reducer.
Does one of the following:
    - Let's action pass, manipulates it, logs it, or stops it.
Middleware is like the gatekeeper/bouncer.
YOu can have 0 to 100+ pieces of middleware. They are all just functions that take in actions
before hitting reducer.

    index.js
        import ReduxPromise from 'redux-promise';
        const createStoreWithMiddleware = applyMiddleware(ReduxPromise)(createStore);

        ReactDOM.render(
            <Provider store={createStoreWithMiddleware(reducers)}>

------Redux-Promise Continued.------

Basically this returns a promise not data

    actions/index.js
        const request = axios.get(url);
    
which is then assigned to payload and sent off to reducer

        payload: request

    reducers/reducer_weather.js
        export default function(state=null, action) {
        console.log('Action received', action);

        return state;
    }

The data is then retrieved once the promise is resolved by redux-promise, which is middleware.

    index.js
        import ReduxPromise from 'redux-promise';

which then sends off to the reducer. Remember the action will also always accompany the data(payload).
Again, redux-promise is a great example of all the heavy lifting middleware can do.
This way we no longer have to appen complicated code using callback/.then to our basi async axios call.

------Avoiding state mutations in Reducers------

Huge pitfall do not do this because will change and mutate your state.

    reducers/reducer_weather.js
        return state.concat([action.payload.data])
    
This is like the same rule where you cannot make this.state = something you have to use setState function.
Instead use concat because it will still leave orginal state in tact but instead creates a new state.

        // return state.concat([action.payload.data]); // Goal is to add to list(aka add to state) more cities.
        // Equivalent to this.
        return [ action.paylod.data, ...state ]; // Flattens this out to [ city, city, city ] not [ city, [city, city,] 
